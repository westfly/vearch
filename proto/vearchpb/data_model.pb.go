// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: data_model.proto

package vearchpb

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"

	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FieldType int32

const (
	FieldType_INT      FieldType = 0
	FieldType_LONG     FieldType = 1
	FieldType_FLOAT    FieldType = 2
	FieldType_DOUBLE   FieldType = 3
	FieldType_STRING   FieldType = 4
	FieldType_VECTOR   FieldType = 5
	FieldType_BOOL     FieldType = 6
	FieldType_GEOPOINT FieldType = 7
	FieldType_DATE     FieldType = 8
)

var FieldType_name = map[int32]string{
	0: "INT",
	1: "LONG",
	2: "FLOAT",
	3: "DOUBLE",
	4: "STRING",
	5: "VECTOR",
	6: "BOOL",
	7: "GEOPOINT",
	8: "DATE",
}

var FieldType_value = map[string]int32{
	"INT":      0,
	"LONG":     1,
	"FLOAT":    2,
	"DOUBLE":   3,
	"STRING":   4,
	"VECTOR":   5,
	"BOOL":     6,
	"GEOPOINT": 7,
	"DATE":     8,
}

func (x FieldType) String() string {
	return proto.EnumName(FieldType_name, int32(x))
}

func (FieldType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{0}
}

// Whether index this field
type FieldOption int32

const (
	FieldOption_Null  FieldOption = 0
	FieldOption_Index FieldOption = 1
)

var FieldOption_name = map[int32]string{
	0: "Null",
	1: "Index",
}

var FieldOption_value = map[string]int32{
	"Null":  0,
	"Index": 1,
}

func (x FieldOption) String() string {
	return proto.EnumName(FieldOption_name, int32(x))
}

func (FieldOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{1}
}

type VectorMetaInfo_ValueType int32

const (
	VectorMetaInfo_FLOAT VectorMetaInfo_ValueType = 0
	VectorMetaInfo_UINT8 VectorMetaInfo_ValueType = 1
)

var VectorMetaInfo_ValueType_name = map[int32]string{
	0: "FLOAT",
	1: "UINT8",
}

var VectorMetaInfo_ValueType_value = map[string]int32{
	"FLOAT": 0,
	"UINT8": 1,
}

func (x VectorMetaInfo_ValueType) String() string {
	return proto.EnumName(VectorMetaInfo_ValueType_name, int32(x))
}

func (VectorMetaInfo_ValueType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{6, 0}
}

type VectorMetaInfo_StoreType int32

const (
	VectorMetaInfo_MMAP    VectorMetaInfo_StoreType = 0
	VectorMetaInfo_ROCKSDB VectorMetaInfo_StoreType = 1
)

var VectorMetaInfo_StoreType_name = map[int32]string{
	0: "MMAP",
	1: "ROCKSDB",
}

var VectorMetaInfo_StoreType_value = map[string]int32{
	"MMAP":    0,
	"ROCKSDB": 1,
}

func (x VectorMetaInfo_StoreType) String() string {
	return proto.EnumName(VectorMetaInfo_StoreType_name, int32(x))
}

func (VectorMetaInfo_StoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{6, 1}
}

type FieldMetaInfo_DataType int32

const (
	FieldMetaInfo_INT    FieldMetaInfo_DataType = 0
	FieldMetaInfo_LONG   FieldMetaInfo_DataType = 1
	FieldMetaInfo_FLOAT  FieldMetaInfo_DataType = 2
	FieldMetaInfo_DOUBLE FieldMetaInfo_DataType = 3
	FieldMetaInfo_STRING FieldMetaInfo_DataType = 4
	FieldMetaInfo_VECTOR FieldMetaInfo_DataType = 5
)

var FieldMetaInfo_DataType_name = map[int32]string{
	0: "INT",
	1: "LONG",
	2: "FLOAT",
	3: "DOUBLE",
	4: "STRING",
	5: "VECTOR",
}

var FieldMetaInfo_DataType_value = map[string]int32{
	"INT":    0,
	"LONG":   1,
	"FLOAT":  2,
	"DOUBLE": 3,
	"STRING": 4,
	"VECTOR": 5,
}

func (x FieldMetaInfo_DataType) String() string {
	return proto.EnumName(FieldMetaInfo_DataType_name, int32(x))
}

func (FieldMetaInfo_DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{7, 0}
}

type TableMetaInfo_KeyType int32

const (
	TableMetaInfo_LONG   TableMetaInfo_KeyType = 0
	TableMetaInfo_STRING TableMetaInfo_KeyType = 1
)

var TableMetaInfo_KeyType_name = map[int32]string{
	0: "LONG",
	1: "STRING",
}

var TableMetaInfo_KeyType_value = map[string]int32{
	"LONG":   0,
	"STRING": 1,
}

func (x TableMetaInfo_KeyType) String() string {
	return proto.EnumName(TableMetaInfo_KeyType_name, int32(x))
}

func (TableMetaInfo_KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{8, 0}
}

type Vector struct {
	Feature              []float32 `protobuf:"fixed32,1,rep,packed,name=feature,proto3" json:"feature,omitempty"`
	Source               string    `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Vector) Reset()      { *m = Vector{} }
func (*Vector) ProtoMessage() {}
func (*Vector) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{0}
}
func (m *Vector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector.Merge(m, src)
}
func (m *Vector) XXX_Size() int {
	return m.Size()
}
func (m *Vector) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector.DiscardUnknown(m)
}

var xxx_messageInfo_Vector proto.InternalMessageInfo

type Field struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 FieldType   `protobuf:"varint,2,opt,name=type,proto3,enum=FieldType" json:"type,omitempty"`
	Value                []byte      `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Option               FieldOption `protobuf:"varint,4,opt,name=option,proto3,enum=FieldOption" json:"option,omitempty"`
	Source               string      `protobuf:"bytes,5,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Field) Reset()      { *m = Field{} }
func (*Field) ProtoMessage() {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{1}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

type Document struct {
	PKey                 string   `protobuf:"bytes,1,opt,name=p_key,json=pKey,proto3" json:"p_key,omitempty"`
	Fields               []*Field `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Document) Reset()      { *m = Document{} }
func (*Document) ProtoMessage() {}
func (*Document) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{2}
}
func (m *Document) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Document) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Document.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Document) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Document.Merge(m, src)
}
func (m *Document) XXX_Size() int {
	return m.Size()
}
func (m *Document) XXX_DiscardUnknown() {
	xxx_messageInfo_Document.DiscardUnknown(m)
}

var xxx_messageInfo_Document proto.InternalMessageInfo

func (m *Document) GetPKey() string {
	if m != nil {
		return m.PKey
	}
	return ""
}

func (m *Document) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Item struct {
	Err                  *Error    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Doc                  *Document `protobuf:"bytes,2,opt,name=doc,proto3" json:"doc,omitempty"`
	Msg                  string    `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Item) Reset()      { *m = Item{} }
func (*Item) ProtoMessage() {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{3}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *Item) GetDoc() *Document {
	if m != nil {
		return m.Doc
	}
	return nil
}

func (m *Item) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type ModelParameters struct {
	JsonParametersStr    string            `protobuf:"bytes,1,opt,name=json_parameters_str,json=jsonParametersStr,proto3" json:"json_parameters_str,omitempty"`
	Parameters           map[string]string `protobuf:"bytes,2,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ModelParameters) Reset()      { *m = ModelParameters{} }
func (*ModelParameters) ProtoMessage() {}
func (*ModelParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{4}
}
func (m *ModelParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelParameters.Merge(m, src)
}
func (m *ModelParameters) XXX_Size() int {
	return m.Size()
}
func (m *ModelParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelParameters.DiscardUnknown(m)
}

var xxx_messageInfo_ModelParameters proto.InternalMessageInfo

type Model struct {
	Name                 string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ModelParameters      *ModelParameters `protobuf:"bytes,2,opt,name=model_parameters,json=modelParameters,proto3" json:"model_parameters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Model) Reset()      { *m = Model{} }
func (*Model) ProtoMessage() {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{5}
}
func (m *Model) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return m.Size()
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

type VectorMetaInfo struct {
	Dimension            int32                    `protobuf:"varint,1,opt,name=dimension,proto3" json:"dimension,omitempty"`
	ValueType            VectorMetaInfo_ValueType `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=VectorMetaInfo_ValueType" json:"value_type,omitempty"`
	StoreType            VectorMetaInfo_StoreType `protobuf:"varint,3,opt,name=store_type,json=storeType,proto3,enum=VectorMetaInfo_StoreType" json:"store_type,omitempty"`
	StoreCacheSize       int32                    `protobuf:"varint,4,opt,name=store_cache_size,json=storeCacheSize,proto3" json:"store_cache_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *VectorMetaInfo) Reset()      { *m = VectorMetaInfo{} }
func (*VectorMetaInfo) ProtoMessage() {}
func (*VectorMetaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{6}
}
func (m *VectorMetaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorMetaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorMetaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorMetaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorMetaInfo.Merge(m, src)
}
func (m *VectorMetaInfo) XXX_Size() int {
	return m.Size()
}
func (m *VectorMetaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorMetaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VectorMetaInfo proto.InternalMessageInfo

type FieldMetaInfo struct {
	Name                 string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DataType             FieldMetaInfo_DataType `protobuf:"varint,2,opt,name=data_type,json=dataType,proto3,enum=FieldMetaInfo_DataType" json:"data_type,omitempty"`
	IsIndex              bool                   `protobuf:"varint,3,opt,name=is_index,json=isIndex,proto3" json:"is_index,omitempty"`
	IsStore              bool                   `protobuf:"varint,4,opt,name=is_store,json=isStore,proto3" json:"is_store,omitempty"`
	VectorMetaInfo       *VectorMetaInfo        `protobuf:"bytes,5,opt,name=vector_meta_info,json=vectorMetaInfo,proto3" json:"vector_meta_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *FieldMetaInfo) Reset()      { *m = FieldMetaInfo{} }
func (*FieldMetaInfo) ProtoMessage() {}
func (*FieldMetaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{7}
}
func (m *FieldMetaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldMetaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldMetaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldMetaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldMetaInfo.Merge(m, src)
}
func (m *FieldMetaInfo) XXX_Size() int {
	return m.Size()
}
func (m *FieldMetaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldMetaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FieldMetaInfo proto.InternalMessageInfo

type TableMetaInfo struct {
	PrimaryKeyName       string                `protobuf:"bytes,1,opt,name=primary_key_name,json=primaryKeyName,proto3" json:"primary_key_name,omitempty"`
	PrimaryKeyType       TableMetaInfo_KeyType `protobuf:"varint,2,opt,name=primary_key_type,json=primaryKeyType,proto3,enum=TableMetaInfo_KeyType" json:"primary_key_type,omitempty"`
	PartitionsNum        int32                 `protobuf:"varint,3,opt,name=partitions_num,json=partitionsNum,proto3" json:"partitions_num,omitempty"`
	ReplicasNum          int32                 `protobuf:"varint,4,opt,name=replicas_num,json=replicasNum,proto3" json:"replicas_num,omitempty"`
	FieldMetaInfo        []*FieldMetaInfo      `protobuf:"bytes,5,rep,name=field_meta_info,json=fieldMetaInfo,proto3" json:"field_meta_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TableMetaInfo) Reset()      { *m = TableMetaInfo{} }
func (*TableMetaInfo) ProtoMessage() {}
func (*TableMetaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{8}
}
func (m *TableMetaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableMetaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableMetaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableMetaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableMetaInfo.Merge(m, src)
}
func (m *TableMetaInfo) XXX_Size() int {
	return m.Size()
}
func (m *TableMetaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableMetaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableMetaInfo proto.InternalMessageInfo

type Table struct {
	Name                 string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TableMetaInfo        *TableMetaInfo `protobuf:"bytes,2,opt,name=table_meta_info,json=tableMetaInfo,proto3" json:"table_meta_info,omitempty"`
	StartIndexingSize    int32          `protobuf:"varint,3,opt,name=start_indexing_size,json=startIndexingSize,proto3" json:"start_indexing_size,omitempty"`
	Model                *Model         `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	TotalDocsSize        int64          `protobuf:"varint,5,opt,name=total_docs_size,json=totalDocsSize,proto3" json:"total_docs_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Table) Reset()      { *m = Table{} }
func (*Table) ProtoMessage() {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{9}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Table.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

type DB struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Tables               []*Table          `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables,omitempty"`
	UserPasswordPair     map[string]string `protobuf:"bytes,3,rep,name=user_password_pair,json=userPasswordPair,proto3" json:"user_password_pair,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DB) Reset()      { *m = DB{} }
func (*DB) ProtoMessage() {}
func (*DB) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a1ecda052abe117, []int{10}
}
func (m *DB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DB.Merge(m, src)
}
func (m *DB) XXX_Size() int {
	return m.Size()
}
func (m *DB) XXX_DiscardUnknown() {
	xxx_messageInfo_DB.DiscardUnknown(m)
}

var xxx_messageInfo_DB proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("FieldType", FieldType_name, FieldType_value)
	proto.RegisterEnum("FieldOption", FieldOption_name, FieldOption_value)
	proto.RegisterEnum("VectorMetaInfo_ValueType", VectorMetaInfo_ValueType_name, VectorMetaInfo_ValueType_value)
	proto.RegisterEnum("VectorMetaInfo_StoreType", VectorMetaInfo_StoreType_name, VectorMetaInfo_StoreType_value)
	proto.RegisterEnum("FieldMetaInfo_DataType", FieldMetaInfo_DataType_name, FieldMetaInfo_DataType_value)
	proto.RegisterEnum("TableMetaInfo_KeyType", TableMetaInfo_KeyType_name, TableMetaInfo_KeyType_value)
	proto.RegisterType((*Vector)(nil), "Vector")
	proto.RegisterType((*Field)(nil), "Field")
	proto.RegisterType((*Document)(nil), "Document")
	proto.RegisterType((*Item)(nil), "Item")
	proto.RegisterType((*ModelParameters)(nil), "ModelParameters")
	proto.RegisterMapType((map[string]string)(nil), "ModelParameters.ParametersEntry")
	proto.RegisterType((*Model)(nil), "Model")
	proto.RegisterType((*VectorMetaInfo)(nil), "VectorMetaInfo")
	proto.RegisterType((*FieldMetaInfo)(nil), "FieldMetaInfo")
	proto.RegisterType((*TableMetaInfo)(nil), "TableMetaInfo")
	proto.RegisterType((*Table)(nil), "Table")
	proto.RegisterType((*DB)(nil), "DB")
	proto.RegisterMapType((map[string]string)(nil), "DB.UserPasswordPairEntry")
}

func init() { proto.RegisterFile("data_model.proto", fileDescriptor_3a1ecda052abe117) }

var fileDescriptor_3a1ecda052abe117 = []byte{
	// 1107 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xbd, 0x6f, 0x23, 0x45,
	0x14, 0xf7, 0xda, 0x5e, 0x7f, 0x3c, 0xc7, 0xf6, 0xde, 0x1c, 0x1c, 0xbe, 0x10, 0xed, 0xe5, 0x56,
	0x80, 0xac, 0x93, 0xd8, 0x93, 0x02, 0x3a, 0x85, 0x43, 0xa0, 0xc4, 0xb1, 0x2f, 0x58, 0x49, 0xec,
	0x68, 0xe2, 0x44, 0x88, 0x66, 0xb5, 0xb1, 0xc7, 0xc9, 0x82, 0xd7, 0xb3, 0x9a, 0x1d, 0x07, 0x7c,
	0x15, 0x25, 0x1d, 0x05, 0xcd, 0x55, 0x88, 0x92, 0x3f, 0x81, 0x12, 0x51, 0xa0, 0xa3, 0xa3, 0xa4,
	0xbc, 0x98, 0x7f, 0x80, 0x92, 0x12, 0xcd, 0xdb, 0xf5, 0xc7, 0x46, 0xa1, 0x40, 0x74, 0x6f, 0x7e,
	0xef, 0x63, 0xde, 0xfb, 0xcd, 0x7b, 0x6f, 0x17, 0x8c, 0x81, 0x2b, 0x5d, 0xc7, 0xe7, 0x03, 0x36,
	0xb2, 0x03, 0xc1, 0x25, 0x5f, 0x5f, 0x63, 0x42, 0x70, 0x11, 0xc6, 0xa7, 0x77, 0x2f, 0x3c, 0x79,
	0x39, 0x39, 0xb7, 0xfb, 0xdc, 0x7f, 0x7c, 0xc1, 0x2f, 0xf8, 0x63, 0x84, 0xcf, 0x27, 0x43, 0x3c,
	0xe1, 0x01, 0xa5, 0xc8, 0xdc, 0xfa, 0x18, 0x72, 0x67, 0xac, 0x2f, 0xb9, 0x20, 0x1b, 0x90, 0x1f,
	0x32, 0x57, 0x4e, 0x04, 0xab, 0x69, 0x9b, 0x99, 0x7a, 0xba, 0x91, 0x36, 0x34, 0x3a, 0x87, 0xc8,
	0x3d, 0xc8, 0x85, 0x7c, 0x22, 0xfa, 0xac, 0x96, 0xde, 0xd4, 0xea, 0x45, 0x1a, 0x9f, 0xac, 0x6f,
	0x35, 0xd0, 0x9f, 0x79, 0x6c, 0x34, 0x20, 0x04, 0xb2, 0x63, 0xd7, 0x57, 0xce, 0x4a, 0x8f, 0x32,
	0x31, 0x21, 0x2b, 0xa7, 0x41, 0xe4, 0x53, 0xd9, 0x02, 0x1b, 0x2d, 0x7b, 0xd3, 0x80, 0x51, 0xc4,
	0xc9, 0x6b, 0xa0, 0x5f, 0xb9, 0xa3, 0x09, 0xab, 0x65, 0x36, 0xb5, 0xfa, 0x1a, 0x8d, 0x0e, 0xe4,
	0x2d, 0xc8, 0xf1, 0x40, 0x7a, 0x7c, 0x5c, 0xcb, 0xa2, 0xdf, 0x5a, 0xe4, 0xd7, 0x45, 0x8c, 0xc6,
	0xba, 0x95, 0x8c, 0xf4, 0x44, 0x46, 0x2d, 0x28, 0x34, 0x79, 0x7f, 0xe2, 0xb3, 0xb1, 0x24, 0x77,
	0x41, 0x0f, 0x9c, 0x2f, 0xd8, 0x74, 0x9e, 0x54, 0x70, 0xc0, 0xa6, 0xc4, 0x84, 0xdc, 0x50, 0xc5,
	0x0b, 0x6b, 0xe9, 0xcd, 0x4c, 0xbd, 0xb4, 0x95, 0x8b, 0xc2, 0xd3, 0x18, 0x7d, 0x9a, 0xfd, 0xe6,
	0x87, 0x07, 0x9a, 0x75, 0x0a, 0xd9, 0xb6, 0x64, 0x3e, 0xa9, 0x41, 0x86, 0x09, 0x81, 0x01, 0x94,
	0x69, 0x4b, 0x71, 0x4d, 0x15, 0x44, 0xde, 0x84, 0xcc, 0x80, 0xf7, 0xb1, 0xb6, 0xd2, 0x56, 0xd1,
	0x9e, 0x5f, 0x4a, 0x15, 0x4a, 0x0c, 0xc8, 0xf8, 0xe1, 0x05, 0xd6, 0x55, 0xa4, 0x4a, 0x8c, 0xc3,
	0xfe, 0xa2, 0x41, 0xf5, 0x48, 0x3d, 0xde, 0xb1, 0x2b, 0x5c, 0x9f, 0x49, 0x26, 0x42, 0x62, 0xc3,
	0xdd, 0xcf, 0x43, 0x3e, 0x76, 0x82, 0x05, 0xe4, 0x84, 0x52, 0xc4, 0x39, 0xdf, 0x51, 0xaa, 0xa5,
	0xf1, 0x89, 0x14, 0x64, 0x07, 0x60, 0x69, 0x1a, 0x17, 0xb1, 0x69, 0xdf, 0x88, 0x6a, 0x2f, 0xc5,
	0xd6, 0x58, 0x8a, 0x29, 0x5d, 0xf1, 0x59, 0xff, 0x08, 0xaa, 0x37, 0xd4, 0x2a, 0xe1, 0x25, 0x51,
	0x4a, 0x5c, 0x3e, 0x4e, 0xf4, 0xe2, 0xd1, 0xe1, 0x69, 0x7a, 0x5b, 0xb3, 0x3e, 0x05, 0x1d, 0x6f,
	0xbb, 0xf5, 0xcd, 0x3f, 0x04, 0x03, 0xbb, 0xd3, 0x49, 0xe4, 0xa8, 0x38, 0x32, 0x6e, 0xe6, 0x48,
	0xab, 0x7e, 0x12, 0xb0, 0xbe, 0x4b, 0x43, 0x25, 0xea, 0xc7, 0x23, 0x26, 0xdd, 0xf6, 0x78, 0xc8,
	0xc9, 0x06, 0x14, 0x07, 0x9e, 0xcf, 0xc6, 0xa1, 0x6a, 0x08, 0x75, 0x91, 0x4e, 0x97, 0x00, 0xd9,
	0x06, 0xc0, 0xbc, 0x9c, 0x95, 0x3e, 0xbb, 0x6f, 0x27, 0x43, 0xd8, 0x67, 0xca, 0x02, 0xdb, 0xae,
	0x78, 0x35, 0x17, 0x95, 0x67, 0x28, 0xb9, 0x88, 0x3d, 0x33, 0xb7, 0x7b, 0x9e, 0x28, 0x8b, 0xc8,
	0x33, 0x9c, 0x8b, 0xa4, 0x0e, 0x46, 0xe4, 0xd9, 0x77, 0xfb, 0x97, 0xcc, 0x09, 0xbd, 0xe7, 0x0c,
	0x3b, 0x55, 0xa7, 0x15, 0xc4, 0xf7, 0x14, 0x7c, 0xe2, 0x3d, 0x67, 0xd6, 0x43, 0x28, 0x2e, 0xee,
	0x26, 0x45, 0xd0, 0x9f, 0x1d, 0x76, 0x77, 0x7b, 0x46, 0x4a, 0x89, 0xa7, 0xed, 0x4e, 0x6f, 0xdb,
	0xd0, 0x2c, 0x0b, 0x8a, 0x8b, 0x4b, 0x48, 0x01, 0xb2, 0x47, 0x47, 0xbb, 0xc7, 0x46, 0x8a, 0x94,
	0x20, 0x4f, 0xbb, 0x7b, 0x07, 0x27, 0xcd, 0x86, 0xa1, 0x59, 0x2f, 0xd2, 0x50, 0xc6, 0x1e, 0x5d,
	0x90, 0x72, 0x1b, 0xf1, 0xef, 0x43, 0x11, 0x77, 0xc3, 0x0a, 0x13, 0x6f, 0xd8, 0x09, 0x37, 0xbb,
	0xe9, 0x4a, 0x17, 0xab, 0x29, 0x0c, 0x62, 0x89, 0xdc, 0x87, 0x82, 0x17, 0x3a, 0xde, 0x78, 0xc0,
	0xbe, 0x42, 0x12, 0x0a, 0x34, 0xef, 0x85, 0x6d, 0x75, 0x8c, 0x55, 0x58, 0x12, 0xd6, 0x87, 0x2a,
	0x4c, 0x96, 0x7c, 0x00, 0xc6, 0x15, 0x32, 0xe5, 0xf8, 0x4c, 0xba, 0x8e, 0x37, 0x1e, 0x72, 0x1c,
	0xc3, 0xd2, 0x56, 0xf5, 0x06, 0x85, 0xb4, 0x72, 0x95, 0x38, 0x5b, 0x87, 0x50, 0x98, 0xa7, 0x41,
	0xf2, 0x90, 0x69, 0x77, 0x14, 0x21, 0x05, 0xc8, 0x1e, 0x76, 0x3b, 0xfb, 0x86, 0xb6, 0x64, 0x29,
	0x4d, 0x00, 0x72, 0xcd, 0xee, 0x69, 0xe3, 0xb0, 0x65, 0x64, 0x94, 0x7c, 0xd2, 0xa3, 0xed, 0xce,
	0xbe, 0x91, 0x55, 0xf2, 0x59, 0x6b, 0xaf, 0xd7, 0xa5, 0x86, 0x6e, 0x7d, 0x9f, 0x86, 0x72, 0xcf,
	0x3d, 0x1f, 0xb1, 0x05, 0x35, 0x75, 0x30, 0x02, 0xe1, 0xf9, 0xae, 0x98, 0xaa, 0xc9, 0x77, 0x56,
	0x68, 0xaa, 0xc4, 0xf8, 0x01, 0x9b, 0x76, 0x14, 0x61, 0x3b, 0x49, 0xcb, 0x15, 0xde, 0xee, 0xd9,
	0x89, 0x98, 0xf6, 0x01, 0x9b, 0x22, 0x6d, 0x2b, 0x11, 0x30, 0xff, 0xb7, 0xa1, 0x12, 0xb8, 0x42,
	0x7a, 0x6a, 0x21, 0x85, 0xce, 0x78, 0xe2, 0x23, 0x85, 0x3a, 0x2d, 0x2f, 0xd1, 0xce, 0xc4, 0x27,
	0x0f, 0x61, 0x4d, 0xb0, 0x60, 0xe4, 0xf5, 0xdd, 0xc8, 0x28, 0x6a, 0x96, 0xd2, 0x1c, 0x53, 0x26,
	0x4f, 0xa0, 0x8a, 0xeb, 0x27, 0xc1, 0xa7, 0x1a, 0xec, 0x4a, 0xf2, 0x09, 0x69, 0x79, 0xb8, 0x7a,
	0xb4, 0x1e, 0x40, 0x7e, 0x9e, 0xcc, 0x9c, 0xc3, 0xd4, 0x0a, 0x59, 0x9a, 0xf5, 0x9b, 0x06, 0x3a,
	0x16, 0x73, 0x6b, 0xcf, 0x3c, 0x81, 0xaa, 0x54, 0xca, 0x95, 0x6b, 0xa3, 0x59, 0xad, 0x24, 0x19,
	0xa0, 0x65, 0x99, 0x20, 0xd9, 0x86, 0xbb, 0xa1, 0x74, 0x85, 0x8c, 0x1a, 0xc7, 0x1b, 0x5f, 0x44,
	0x53, 0x10, 0x55, 0x7f, 0x07, 0x55, 0xed, 0x58, 0xa3, 0x06, 0x81, 0x6c, 0x80, 0x8e, 0xa3, 0x8e,
	0xa5, 0xab, 0x3d, 0x8a, 0x9b, 0x80, 0x46, 0x20, 0x79, 0x07, 0xaa, 0x92, 0x4b, 0x77, 0xe4, 0x0c,
	0x78, 0x3f, 0x8c, 0x22, 0xa9, 0x66, 0xca, 0xd0, 0x32, 0xc2, 0x4d, 0xde, 0x0f, 0x71, 0x9c, 0x7e,
	0xd5, 0x20, 0xdd, 0x6c, 0xfc, 0xcb, 0x97, 0x26, 0x87, 0x19, 0x2e, 0x97, 0x3a, 0xe6, 0x4f, 0x63,
	0x94, 0xec, 0x03, 0x99, 0x84, 0x4c, 0x38, 0x81, 0x1b, 0x86, 0x5f, 0x72, 0x31, 0x70, 0x02, 0xd7,
	0x13, 0xb5, 0x0c, 0xda, 0xde, 0xb7, 0x9b, 0x0d, 0xfb, 0x34, 0x64, 0xe2, 0x38, 0x56, 0x1e, 0xbb,
	0x9e, 0x88, 0x96, 0xa6, 0x31, 0xb9, 0x01, 0xaf, 0xef, 0xc1, 0xeb, 0xb7, 0x9a, 0xfe, 0x97, 0x05,
	0xfa, 0x88, 0x43, 0x71, 0xf1, 0x29, 0xfc, 0xff, 0x43, 0xa0, 0x1c, 0x1b, 0xdd, 0xee, 0xa1, 0x91,
	0x23, 0x6b, 0x50, 0xd8, 0x6f, 0x75, 0x8f, 0xbb, 0x2a, 0x60, 0x5e, 0xe1, 0xcd, 0xdd, 0x5e, 0xcb,
	0x28, 0x3c, 0xb2, 0xa0, 0xb4, 0xf2, 0x0d, 0x55, 0x8a, 0xce, 0x64, 0x34, 0x8a, 0x36, 0x11, 0x3e,
	0x94, 0xa1, 0x35, 0x76, 0x5e, 0x5e, 0x9b, 0xa9, 0x3f, 0xae, 0xcd, 0xd4, 0xab, 0x6b, 0x33, 0xf5,
	0xd7, 0xb5, 0x99, 0xfa, 0xfb, 0xda, 0xd4, 0xbe, 0x9e, 0x99, 0xda, 0x8f, 0x33, 0x53, 0xfb, 0x69,
	0x66, 0xa6, 0x7e, 0x9e, 0x99, 0xa9, 0x97, 0x33, 0x53, 0xfb, 0x7d, 0x66, 0x6a, 0xaf, 0x66, 0xa6,
	0xf6, 0xe2, 0x4f, 0x33, 0xf5, 0x89, 0xf6, 0x59, 0xe1, 0x8a, 0xb9, 0xa2, 0x7f, 0x19, 0x9c, 0x9f,
	0xe7, 0xf0, 0x9f, 0xe2, 0xbd, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x1b, 0xc6, 0x79, 0x58, 0xa4,
	0x08, 0x00, 0x00,
}

func (this *Vector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vector)
	if !ok {
		that2, ok := that.(Vector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Feature) != len(that1.Feature) {
		return false
	}
	for i := range this.Feature {
		if this.Feature[i] != that1.Feature[i] {
			return false
		}
	}
	if this.Source != that1.Source {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Field) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Field)
	if !ok {
		that2, ok := that.(Field)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if this.Option != that1.Option {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Document) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Document)
	if !ok {
		that2, ok := that.(Document)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PKey != that1.PKey {
		return false
	}
	if len(this.Fields) != len(that1.Fields) {
		return false
	}
	for i := range this.Fields {
		if !this.Fields[i].Equal(that1.Fields[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Item)
	if !ok {
		that2, ok := that.(Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Err.Equal(that1.Err) {
		return false
	}
	if !this.Doc.Equal(that1.Doc) {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ModelParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelParameters)
	if !ok {
		that2, ok := that.(ModelParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JsonParametersStr != that1.JsonParametersStr {
		return false
	}
	if len(this.Parameters) != len(that1.Parameters) {
		return false
	}
	for i := range this.Parameters {
		if this.Parameters[i] != that1.Parameters[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Model) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Model)
	if !ok {
		that2, ok := that.(Model)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.ModelParameters.Equal(that1.ModelParameters) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VectorMetaInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorMetaInfo)
	if !ok {
		that2, ok := that.(VectorMetaInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dimension != that1.Dimension {
		return false
	}
	if this.ValueType != that1.ValueType {
		return false
	}
	if this.StoreType != that1.StoreType {
		return false
	}
	if this.StoreCacheSize != that1.StoreCacheSize {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FieldMetaInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldMetaInfo)
	if !ok {
		that2, ok := that.(FieldMetaInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.DataType != that1.DataType {
		return false
	}
	if this.IsIndex != that1.IsIndex {
		return false
	}
	if this.IsStore != that1.IsStore {
		return false
	}
	if !this.VectorMetaInfo.Equal(that1.VectorMetaInfo) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TableMetaInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableMetaInfo)
	if !ok {
		that2, ok := that.(TableMetaInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrimaryKeyName != that1.PrimaryKeyName {
		return false
	}
	if this.PrimaryKeyType != that1.PrimaryKeyType {
		return false
	}
	if this.PartitionsNum != that1.PartitionsNum {
		return false
	}
	if this.ReplicasNum != that1.ReplicasNum {
		return false
	}
	if len(this.FieldMetaInfo) != len(that1.FieldMetaInfo) {
		return false
	}
	for i := range this.FieldMetaInfo {
		if !this.FieldMetaInfo[i].Equal(that1.FieldMetaInfo[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Table) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Table)
	if !ok {
		that2, ok := that.(Table)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.TableMetaInfo.Equal(that1.TableMetaInfo) {
		return false
	}
	if this.StartIndexingSize != that1.StartIndexingSize {
		return false
	}
	if !this.Model.Equal(that1.Model) {
		return false
	}
	if this.TotalDocsSize != that1.TotalDocsSize {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DB) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DB)
	if !ok {
		that2, ok := that.(DB)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Tables) != len(that1.Tables) {
		return false
	}
	for i := range this.Tables {
		if !this.Tables[i].Equal(that1.Tables[i]) {
			return false
		}
	}
	if len(this.UserPasswordPair) != len(that1.UserPasswordPair) {
		return false
	}
	for i := range this.UserPasswordPair {
		if this.UserPasswordPair[i] != that1.UserPasswordPair[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (m *Vector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Feature) > 0 {
		for iNdEx := len(m.Feature) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float32bits(float32(m.Feature[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
		}
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Feature)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Option != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.Option))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Document) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDataModel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PKey) > 0 {
		i -= len(m.PKey)
		copy(dAtA[i:], m.PKey)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.PKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Doc != nil {
		{
			size, err := m.Doc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataModel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataModel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Parameters) > 0 {
		for k := range m.Parameters {
			v := m.Parameters[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDataModel(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDataModel(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDataModel(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.JsonParametersStr) > 0 {
		i -= len(m.JsonParametersStr)
		copy(dAtA[i:], m.JsonParametersStr)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.JsonParametersStr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ModelParameters != nil {
		{
			size, err := m.ModelParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataModel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VectorMetaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorMetaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorMetaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StoreCacheSize != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.StoreCacheSize))
		i--
		dAtA[i] = 0x20
	}
	if m.StoreType != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.StoreType))
		i--
		dAtA[i] = 0x18
	}
	if m.ValueType != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x10
	}
	if m.Dimension != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.Dimension))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldMetaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldMetaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldMetaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VectorMetaInfo != nil {
		{
			size, err := m.VectorMetaInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataModel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.IsStore {
		i--
		if m.IsStore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsIndex {
		i--
		if m.IsIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DataType != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableMetaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableMetaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableMetaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FieldMetaInfo) > 0 {
		for iNdEx := len(m.FieldMetaInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FieldMetaInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDataModel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ReplicasNum != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.ReplicasNum))
		i--
		dAtA[i] = 0x20
	}
	if m.PartitionsNum != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.PartitionsNum))
		i--
		dAtA[i] = 0x18
	}
	if m.PrimaryKeyType != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.PrimaryKeyType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PrimaryKeyName) > 0 {
		i -= len(m.PrimaryKeyName)
		copy(dAtA[i:], m.PrimaryKeyName)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.PrimaryKeyName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalDocsSize != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.TotalDocsSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataModel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StartIndexingSize != 0 {
		i = encodeVarintDataModel(dAtA, i, uint64(m.StartIndexingSize))
		i--
		dAtA[i] = 0x18
	}
	if m.TableMetaInfo != nil {
		{
			size, err := m.TableMetaInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataModel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserPasswordPair) > 0 {
		for k := range m.UserPasswordPair {
			v := m.UserPasswordPair[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDataModel(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDataModel(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDataModel(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDataModel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDataModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDataModel(dAtA []byte, offset int, v uint64) int {
	offset -= sovDataModel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedVector(r randyDataModel, easy bool) *Vector {
	this := &Vector{}
	v1 := r.Intn(10)
	this.Feature = make([]float32, v1)
	for i := 0; i < v1; i++ {
		this.Feature[i] = float32(r.Float32())
		if r.Intn(2) == 0 {
			this.Feature[i] *= -1
		}
	}
	this.Source = string(randStringDataModel(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 3)
	}
	return this
}

func NewPopulatedField(r randyDataModel, easy bool) *Field {
	this := &Field{}
	this.Name = string(randStringDataModel(r))
	this.Type = FieldType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	v2 := r.Intn(100)
	this.Value = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.Value[i] = byte(r.Intn(256))
	}
	this.Option = FieldOption([]int32{0, 1}[r.Intn(2)])
	this.Source = string(randStringDataModel(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 6)
	}
	return this
}

func NewPopulatedDocument(r randyDataModel, easy bool) *Document {
	this := &Document{}
	this.PKey = string(randStringDataModel(r))
	if r.Intn(5) != 0 {
		v3 := r.Intn(5)
		this.Fields = make([]*Field, v3)
		for i := 0; i < v3; i++ {
			this.Fields[i] = NewPopulatedField(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 3)
	}
	return this
}

func NewPopulatedItem(r randyDataModel, easy bool) *Item {
	this := &Item{}
	if r.Intn(5) != 0 {
		this.Err = NewPopulatedError(r, easy)
	}
	if r.Intn(5) != 0 {
		this.Doc = NewPopulatedDocument(r, easy)
	}
	this.Msg = string(randStringDataModel(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 4)
	}
	return this
}

func NewPopulatedModelParameters(r randyDataModel, easy bool) *ModelParameters {
	this := &ModelParameters{}
	this.JsonParametersStr = string(randStringDataModel(r))
	if r.Intn(5) != 0 {
		v4 := r.Intn(10)
		this.Parameters = make(map[string]string)
		for i := 0; i < v4; i++ {
			this.Parameters[randStringDataModel(r)] = randStringDataModel(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 3)
	}
	return this
}

func NewPopulatedModel(r randyDataModel, easy bool) *Model {
	this := &Model{}
	this.Name = string(randStringDataModel(r))
	if r.Intn(5) != 0 {
		this.ModelParameters = NewPopulatedModelParameters(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 3)
	}
	return this
}

func NewPopulatedVectorMetaInfo(r randyDataModel, easy bool) *VectorMetaInfo {
	this := &VectorMetaInfo{}
	this.Dimension = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Dimension *= -1
	}
	this.ValueType = VectorMetaInfo_ValueType([]int32{0, 1}[r.Intn(2)])
	this.StoreType = VectorMetaInfo_StoreType([]int32{0, 1}[r.Intn(2)])
	this.StoreCacheSize = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.StoreCacheSize *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 5)
	}
	return this
}

func NewPopulatedFieldMetaInfo(r randyDataModel, easy bool) *FieldMetaInfo {
	this := &FieldMetaInfo{}
	this.Name = string(randStringDataModel(r))
	this.DataType = FieldMetaInfo_DataType([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	this.IsIndex = bool(bool(r.Intn(2) == 0))
	this.IsStore = bool(bool(r.Intn(2) == 0))
	if r.Intn(5) != 0 {
		this.VectorMetaInfo = NewPopulatedVectorMetaInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 6)
	}
	return this
}

func NewPopulatedTableMetaInfo(r randyDataModel, easy bool) *TableMetaInfo {
	this := &TableMetaInfo{}
	this.PrimaryKeyName = string(randStringDataModel(r))
	this.PrimaryKeyType = TableMetaInfo_KeyType([]int32{0, 1}[r.Intn(2)])
	this.PartitionsNum = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.PartitionsNum *= -1
	}
	this.ReplicasNum = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ReplicasNum *= -1
	}
	if r.Intn(5) != 0 {
		v5 := r.Intn(5)
		this.FieldMetaInfo = make([]*FieldMetaInfo, v5)
		for i := 0; i < v5; i++ {
			this.FieldMetaInfo[i] = NewPopulatedFieldMetaInfo(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 6)
	}
	return this
}

func NewPopulatedTable(r randyDataModel, easy bool) *Table {
	this := &Table{}
	this.Name = string(randStringDataModel(r))
	if r.Intn(5) != 0 {
		this.TableMetaInfo = NewPopulatedTableMetaInfo(r, easy)
	}
	this.StartIndexingSize = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.StartIndexingSize *= -1
	}
	if r.Intn(5) != 0 {
		this.Model = NewPopulatedModel(r, easy)
	}
	this.TotalDocsSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.TotalDocsSize *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 6)
	}
	return this
}

func NewPopulatedDB(r randyDataModel, easy bool) *DB {
	this := &DB{}
	this.Name = string(randStringDataModel(r))
	if r.Intn(5) != 0 {
		v6 := r.Intn(5)
		this.Tables = make([]*Table, v6)
		for i := 0; i < v6; i++ {
			this.Tables[i] = NewPopulatedTable(r, easy)
		}
	}
	if r.Intn(5) != 0 {
		v7 := r.Intn(10)
		this.UserPasswordPair = make(map[string]string)
		for i := 0; i < v7; i++ {
			this.UserPasswordPair[randStringDataModel(r)] = randStringDataModel(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedDataModel(r, 4)
	}
	return this
}

type randyDataModel interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneDataModel(r randyDataModel) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringDataModel(r randyDataModel) string {
	v8 := r.Intn(100)
	tmps := make([]rune, v8)
	for i := 0; i < v8; i++ {
		tmps[i] = randUTF8RuneDataModel(r)
	}
	return string(tmps)
}
func randUnrecognizedDataModel(r randyDataModel, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldDataModel(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldDataModel(dAtA []byte, r randyDataModel, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateDataModel(dAtA, uint64(key))
		v9 := r.Int63()
		if r.Intn(2) == 0 {
			v9 *= -1
		}
		dAtA = encodeVarintPopulateDataModel(dAtA, uint64(v9))
	case 1:
		dAtA = encodeVarintPopulateDataModel(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateDataModel(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateDataModel(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateDataModel(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateDataModel(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Vector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Feature) > 0 {
		n += 1 + sovDataModel(uint64(len(m.Feature)*4)) + len(m.Feature)*4
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDataModel(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.Option != 0 {
		n += 1 + sovDataModel(uint64(m.Option))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Document) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PKey)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovDataModel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.Doc != nil {
		l = m.Doc.Size()
		n += 1 + l + sovDataModel(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModelParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JsonParametersStr)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDataModel(uint64(len(k))) + 1 + len(v) + sovDataModel(uint64(len(v)))
			n += mapEntrySize + 1 + sovDataModel(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Model) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.ModelParameters != nil {
		l = m.ModelParameters.Size()
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VectorMetaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dimension != 0 {
		n += 1 + sovDataModel(uint64(m.Dimension))
	}
	if m.ValueType != 0 {
		n += 1 + sovDataModel(uint64(m.ValueType))
	}
	if m.StoreType != 0 {
		n += 1 + sovDataModel(uint64(m.StoreType))
	}
	if m.StoreCacheSize != 0 {
		n += 1 + sovDataModel(uint64(m.StoreCacheSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldMetaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.DataType != 0 {
		n += 1 + sovDataModel(uint64(m.DataType))
	}
	if m.IsIndex {
		n += 2
	}
	if m.IsStore {
		n += 2
	}
	if m.VectorMetaInfo != nil {
		l = m.VectorMetaInfo.Size()
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableMetaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrimaryKeyName)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.PrimaryKeyType != 0 {
		n += 1 + sovDataModel(uint64(m.PrimaryKeyType))
	}
	if m.PartitionsNum != 0 {
		n += 1 + sovDataModel(uint64(m.PartitionsNum))
	}
	if m.ReplicasNum != 0 {
		n += 1 + sovDataModel(uint64(m.ReplicasNum))
	}
	if len(m.FieldMetaInfo) > 0 {
		for _, e := range m.FieldMetaInfo {
			l = e.Size()
			n += 1 + l + sovDataModel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.TableMetaInfo != nil {
		l = m.TableMetaInfo.Size()
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.StartIndexingSize != 0 {
		n += 1 + sovDataModel(uint64(m.StartIndexingSize))
	}
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovDataModel(uint64(l))
	}
	if m.TotalDocsSize != 0 {
		n += 1 + sovDataModel(uint64(m.TotalDocsSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDataModel(uint64(l))
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovDataModel(uint64(l))
		}
	}
	if len(m.UserPasswordPair) > 0 {
		for k, v := range m.UserPasswordPair {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDataModel(uint64(len(k))) + 1 + len(v) + sovDataModel(uint64(len(v)))
			n += mapEntrySize + 1 + sovDataModel(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDataModel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDataModel(x uint64) (n int) {
	return sovDataModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Vector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Vector{`,
		`Feature:` + fmt.Sprintf("%v", this.Feature) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Field) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Field{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Option:` + fmt.Sprintf("%v", this.Option) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Document) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFields := "[]*Field{"
	for _, f := range this.Fields {
		repeatedStringForFields += strings.Replace(f.String(), "Field", "Field", 1) + ","
	}
	repeatedStringForFields += "}"
	s := strings.Join([]string{`&Document{`,
		`PKey:` + fmt.Sprintf("%v", this.PKey) + `,`,
		`Fields:` + repeatedStringForFields + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Item{`,
		`Err:` + strings.Replace(fmt.Sprintf("%v", this.Err), "Error", "Error", 1) + `,`,
		`Doc:` + strings.Replace(this.Doc.String(), "Document", "Document", 1) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelParameters) String() string {
	if this == nil {
		return "nil"
	}
	keysForParameters := make([]string, 0, len(this.Parameters))
	for k, _ := range this.Parameters {
		keysForParameters = append(keysForParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForParameters)
	mapStringForParameters := "map[string]string{"
	for _, k := range keysForParameters {
		mapStringForParameters += fmt.Sprintf("%v: %v,", k, this.Parameters[k])
	}
	mapStringForParameters += "}"
	s := strings.Join([]string{`&ModelParameters{`,
		`JsonParametersStr:` + fmt.Sprintf("%v", this.JsonParametersStr) + `,`,
		`Parameters:` + mapStringForParameters + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Model) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Model{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ModelParameters:` + strings.Replace(this.ModelParameters.String(), "ModelParameters", "ModelParameters", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorMetaInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorMetaInfo{`,
		`Dimension:` + fmt.Sprintf("%v", this.Dimension) + `,`,
		`ValueType:` + fmt.Sprintf("%v", this.ValueType) + `,`,
		`StoreType:` + fmt.Sprintf("%v", this.StoreType) + `,`,
		`StoreCacheSize:` + fmt.Sprintf("%v", this.StoreCacheSize) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldMetaInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldMetaInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`IsIndex:` + fmt.Sprintf("%v", this.IsIndex) + `,`,
		`IsStore:` + fmt.Sprintf("%v", this.IsStore) + `,`,
		`VectorMetaInfo:` + strings.Replace(this.VectorMetaInfo.String(), "VectorMetaInfo", "VectorMetaInfo", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TableMetaInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFieldMetaInfo := "[]*FieldMetaInfo{"
	for _, f := range this.FieldMetaInfo {
		repeatedStringForFieldMetaInfo += strings.Replace(f.String(), "FieldMetaInfo", "FieldMetaInfo", 1) + ","
	}
	repeatedStringForFieldMetaInfo += "}"
	s := strings.Join([]string{`&TableMetaInfo{`,
		`PrimaryKeyName:` + fmt.Sprintf("%v", this.PrimaryKeyName) + `,`,
		`PrimaryKeyType:` + fmt.Sprintf("%v", this.PrimaryKeyType) + `,`,
		`PartitionsNum:` + fmt.Sprintf("%v", this.PartitionsNum) + `,`,
		`ReplicasNum:` + fmt.Sprintf("%v", this.ReplicasNum) + `,`,
		`FieldMetaInfo:` + repeatedStringForFieldMetaInfo + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Table) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Table{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`TableMetaInfo:` + strings.Replace(this.TableMetaInfo.String(), "TableMetaInfo", "TableMetaInfo", 1) + `,`,
		`StartIndexingSize:` + fmt.Sprintf("%v", this.StartIndexingSize) + `,`,
		`Model:` + strings.Replace(this.Model.String(), "Model", "Model", 1) + `,`,
		`TotalDocsSize:` + fmt.Sprintf("%v", this.TotalDocsSize) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DB) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTables := "[]*Table{"
	for _, f := range this.Tables {
		repeatedStringForTables += strings.Replace(f.String(), "Table", "Table", 1) + ","
	}
	repeatedStringForTables += "}"
	keysForUserPasswordPair := make([]string, 0, len(this.UserPasswordPair))
	for k, _ := range this.UserPasswordPair {
		keysForUserPasswordPair = append(keysForUserPasswordPair, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForUserPasswordPair)
	mapStringForUserPasswordPair := "map[string]string{"
	for _, k := range keysForUserPasswordPair {
		mapStringForUserPasswordPair += fmt.Sprintf("%v: %v,", k, this.UserPasswordPair[k])
	}
	mapStringForUserPasswordPair += "}"
	s := strings.Join([]string{`&DB{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Tables:` + repeatedStringForTables + `,`,
		`UserPasswordPair:` + mapStringForUserPasswordPair + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringDataModel(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Vector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Feature = append(m.Feature, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDataModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDataModel
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDataModel
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Feature) == 0 {
					m.Feature = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Feature = append(m.Feature, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FieldType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= FieldOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &Error{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Doc == nil {
				m.Doc = &Document{}
			}
			if err := m.Doc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonParametersStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsonParametersStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDataModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDataModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDataModel
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDataModel
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDataModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDataModel
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDataModel
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDataModel(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDataModel
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parameters[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelParameters == nil {
				m.ModelParameters = &ModelParameters{}
			}
			if err := m.ModelParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorMetaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorMetaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorMetaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			m.Dimension = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dimension |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= VectorMetaInfo_ValueType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreType", wireType)
			}
			m.StoreType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreType |= VectorMetaInfo_StoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreCacheSize", wireType)
			}
			m.StoreCacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreCacheSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldMetaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldMetaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldMetaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= FieldMetaInfo_DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsIndex = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStore = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorMetaInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VectorMetaInfo == nil {
				m.VectorMetaInfo = &VectorMetaInfo{}
			}
			if err := m.VectorMetaInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableMetaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableMetaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableMetaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKeyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeyType", wireType)
			}
			m.PrimaryKeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKeyType |= TableMetaInfo_KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionsNum", wireType)
			}
			m.PartitionsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionsNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasNum", wireType)
			}
			m.ReplicasNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicasNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldMetaInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldMetaInfo = append(m.FieldMetaInfo, &FieldMetaInfo{})
			if err := m.FieldMetaInfo[len(m.FieldMetaInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableMetaInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableMetaInfo == nil {
				m.TableMetaInfo = &TableMetaInfo{}
			}
			if err := m.TableMetaInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndexingSize", wireType)
			}
			m.StartIndexingSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndexingSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Model{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDocsSize", wireType)
			}
			m.TotalDocsSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDocsSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &Table{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPasswordPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPasswordPair == nil {
				m.UserPasswordPair = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDataModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDataModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDataModel
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDataModel
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDataModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDataModel
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDataModel
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDataModel(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDataModel
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserPasswordPair[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDataModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDataModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDataModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDataModel
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDataModel
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDataModel
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDataModel        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDataModel          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDataModel = fmt.Errorf("proto: unexpected end of group")
)
