// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package pspb

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type OpType int32

const (
	OpType_NOOP OpType = 0
	// Creates the resource. If there is an existing document with the id, then it won't be removed.
	OpType_CREATE OpType = 1
	// Updates  document. If there an existing document with the id, it will be replaced.
	OpType_MERGE OpType = 2
	//create document if exits it will overy write but version not ++
	OpType_REPLACE OpType = 3
	// Deletes a document
	OpType_DELETE OpType = 4
)

var OpType_name = map[int32]string{
	0: "NOOP",
	1: "CREATE",
	2: "MERGE",
	3: "REPLACE",
	4: "DELETE",
}

var OpType_value = map[string]int32{
	"NOOP":    0,
	"CREATE":  1,
	"MERGE":   2,
	"REPLACE": 3,
	"DELETE":  4,
}

func (x OpType) String() string {
	return proto.EnumName(OpType_name, int32(x))
}

func (OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type FieldType int32

const (
	FieldType_NULL     FieldType = 0
	FieldType_STRING   FieldType = 1
	FieldType_INT      FieldType = 2
	FieldType_FLOAT    FieldType = 3
	FieldType_BOOL     FieldType = 4
	FieldType_GEOPOINT FieldType = 5
	FieldType_DATE     FieldType = 6
	FieldType_VECTOR   FieldType = 7
)

var FieldType_name = map[int32]string{
	0: "NULL",
	1: "STRING",
	2: "INT",
	3: "FLOAT",
	4: "BOOL",
	5: "GEOPOINT",
	6: "DATE",
	7: "VECTOR",
}

var FieldType_value = map[string]int32{
	"NULL":     0,
	"STRING":   1,
	"INT":      2,
	"FLOAT":    3,
	"BOOL":     4,
	"GEOPOINT": 5,
	"DATE":     6,
	"VECTOR":   7,
}

func (x FieldType) String() string {
	return proto.EnumName(FieldType_name, int32(x))
}

func (FieldType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type FieldOption int32

const (
	FieldOption_Null  FieldOption = 0
	FieldOption_Index FieldOption = 1
)

var FieldOption_name = map[int32]string{
	0: "Null",
	1: "Index",
}

var FieldOption_value = map[string]int32{
	"Null":  0,
	"Index": 1,
}

func (x FieldOption) String() string {
	return proto.EnumName(FieldOption_name, int32(x))
}

func (FieldOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}

type UpdateSpace struct {
	Space                []byte   `protobuf:"bytes,1,opt,name=Space,proto3" json:"Space,omitempty"`
	Version              uint64   `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateSpace) Reset()      { *m = UpdateSpace{} }
func (*UpdateSpace) ProtoMessage() {}
func (*UpdateSpace) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *UpdateSpace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSpace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSpace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSpace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSpace.Merge(m, src)
}
func (m *UpdateSpace) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSpace) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSpace.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSpace proto.InternalMessageInfo

type Failure struct {
	DocId                string   `protobuf:"bytes,1,opt,name=doc_id,json=docId,proto3" json:"doc_id,omitempty"`
	Cause                string   `protobuf:"bytes,2,opt,name=cause,proto3" json:"cause,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Failure) Reset()      { *m = Failure{} }
func (*Failure) ProtoMessage() {}
func (*Failure) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *Failure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Failure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Failure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Failure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Failure.Merge(m, src)
}
func (m *Failure) XXX_Size() int {
	return m.Size()
}
func (m *Failure) XXX_DiscardUnknown() {
	xxx_messageInfo_Failure.DiscardUnknown(m)
}

var xxx_messageInfo_Failure proto.InternalMessageInfo

type EngineFailure struct {
	Type                 string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	Status               int64    `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EngineFailure) Reset()      { *m = EngineFailure{} }
func (*EngineFailure) ProtoMessage() {}
func (*EngineFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *EngineFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EngineFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EngineFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineFailure.Merge(m, src)
}
func (m *EngineFailure) XXX_Size() int {
	return m.Size()
}
func (m *EngineFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineFailure.DiscardUnknown(m)
}

var xxx_messageInfo_EngineFailure proto.InternalMessageInfo

type Vector struct {
	Feature              []float32 `protobuf:"fixed32,1,rep,packed,name=feature,proto3" json:"feature,omitempty"`
	Source               string    `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Vector) Reset()      { *m = Vector{} }
func (*Vector) ProtoMessage() {}
func (*Vector) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *Vector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector.Merge(m, src)
}
func (m *Vector) XXX_Size() int {
	return m.Size()
}
func (m *Vector) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector.DiscardUnknown(m)
}

var xxx_messageInfo_Vector proto.InternalMessageInfo

type TimeStamp struct {
	Sec                  int64    `protobuf:"varint,1,opt,name=sec,proto3" json:"sec,omitempty"`
	Usec                 int64    `protobuf:"varint,2,opt,name=usec,proto3" json:"usec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeStamp) Reset()      { *m = TimeStamp{} }
func (*TimeStamp) ProtoMessage() {}
func (*TimeStamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *TimeStamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeStamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeStamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeStamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeStamp.Merge(m, src)
}
func (m *TimeStamp) XXX_Size() int {
	return m.Size()
}
func (m *TimeStamp) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeStamp.DiscardUnknown(m)
}

var xxx_messageInfo_TimeStamp proto.InternalMessageInfo

type Geo struct {
	Lon                  float64  `protobuf:"fixed64,1,opt,name=lon,proto3" json:"lon,omitempty"`
	Lat                  float64  `protobuf:"fixed64,2,opt,name=lat,proto3" json:"lat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Geo) Reset()      { *m = Geo{} }
func (*Geo) ProtoMessage() {}
func (*Geo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *Geo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Geo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Geo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Geo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Geo.Merge(m, src)
}
func (m *Geo) XXX_Size() int {
	return m.Size()
}
func (m *Geo) XXX_DiscardUnknown() {
	xxx_messageInfo_Geo.DiscardUnknown(m)
}

var xxx_messageInfo_Geo proto.InternalMessageInfo

type Field struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 FieldType   `protobuf:"varint,2,opt,name=type,proto3,enum=FieldType" json:"type,omitempty"`
	Value                []byte      `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Option               FieldOption `protobuf:"varint,4,opt,name=option,proto3,enum=FieldOption" json:"option,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Field) Reset()      { *m = Field{} }
func (*Field) ProtoMessage() {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

type DocCmd struct {
	Type    OpType `protobuf:"varint,1,opt,name=type,proto3,enum=OpType" json:"type,omitempty"`
	DocId   string `protobuf:"bytes,2,opt,name=doc_id,json=docId,proto3" json:"doc_id,omitempty"`
	Version int64  `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	//PulloutVersion in docCmd specified version in DocCmd is pulled out
	//from engine or user specified
	PulloutVersion       bool     `protobuf:"varint,4,opt,name=pullout_version,json=pulloutVersion,proto3" json:"pullout_version,omitempty"`
	Slot                 uint32   `protobuf:"varint,5,opt,name=slot,proto3" json:"slot,omitempty"`
	Source               []byte   `protobuf:"bytes,6,opt,name=source,proto3" json:"source,omitempty"`
	Fields               []*Field `protobuf:"bytes,7,rep,name=fields,proto3" json:"fields,omitempty"`
	RetryOnConflict      int32    `protobuf:"varint,8,opt,name=retry_on_conflict,json=retryOnConflict,proto3" json:"retry_on_conflict,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DocCmd) Reset()      { *m = DocCmd{} }
func (*DocCmd) ProtoMessage() {}
func (*DocCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *DocCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocCmd.Merge(m, src)
}
func (m *DocCmd) XXX_Size() int {
	return m.Size()
}
func (m *DocCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_DocCmd.DiscardUnknown(m)
}

var xxx_messageInfo_DocCmd proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("OpType", OpType_name, OpType_value)
	proto.RegisterEnum("FieldType", FieldType_name, FieldType_value)
	proto.RegisterEnum("FieldOption", FieldOption_name, FieldOption_value)
	proto.RegisterType((*UpdateSpace)(nil), "UpdateSpace")
	proto.RegisterType((*Failure)(nil), "Failure")
	proto.RegisterType((*EngineFailure)(nil), "EngineFailure")
	proto.RegisterType((*Vector)(nil), "Vector")
	proto.RegisterType((*TimeStamp)(nil), "TimeStamp")
	proto.RegisterType((*Geo)(nil), "Geo")
	proto.RegisterType((*Field)(nil), "Field")
	proto.RegisterType((*DocCmd)(nil), "DocCmd")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 697 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x53, 0xcf, 0x6b, 0xe3, 0x46,
	0x14, 0xd6, 0x58, 0xbf, 0xec, 0x67, 0x27, 0x51, 0x87, 0xb6, 0x98, 0xb4, 0xa8, 0x46, 0x14, 0xea,
	0x1a, 0xea, 0xd0, 0x14, 0x7a, 0x6a, 0x0b, 0xb1, 0xa3, 0xb8, 0x06, 0x37, 0x0a, 0x63, 0x25, 0x87,
	0x5e, 0x8c, 0x2c, 0x8d, 0x5d, 0x81, 0xac, 0x11, 0xd2, 0x28, 0x34, 0x87, 0x42, 0xff, 0x8c, 0xfe,
	0x09, 0xfd, 0x13, 0xf6, 0xb8, 0xc7, 0x1c, 0xf7, 0xb8, 0xa7, 0x25, 0xf6, 0xfe, 0x03, 0x7b, 0xdb,
	0x3d, 0x2e, 0x33, 0x92, 0xb3, 0xbe, 0x7d, 0xdf, 0xa7, 0xef, 0x7d, 0xf3, 0xde, 0xbc, 0x11, 0xb4,
	0x82, 0x2c, 0x1e, 0x66, 0x39, 0xe3, 0xec, 0xf4, 0x87, 0x75, 0xcc, 0xff, 0x2a, 0x97, 0xc3, 0x90,
	0x6d, 0xce, 0xd6, 0x6c, 0xcd, 0xce, 0xa4, 0xbc, 0x2c, 0x57, 0x92, 0x49, 0x22, 0x51, 0x65, 0x77,
	0x7e, 0x85, 0xf6, 0x6d, 0x16, 0x05, 0x9c, 0xce, 0xb3, 0x20, 0xa4, 0xf8, 0x73, 0xd0, 0x25, 0xe8,
	0xa2, 0x1e, 0xea, 0x77, 0x48, 0x45, 0x70, 0x17, 0xcc, 0x7b, 0x9a, 0x17, 0x31, 0x4b, 0xbb, 0x8d,
	0x1e, 0xea, 0x6b, 0x64, 0x4f, 0x9d, 0x9f, 0xc1, 0xbc, 0x0a, 0xe2, 0xa4, 0xcc, 0x29, 0xfe, 0x02,
	0x8c, 0x88, 0x85, 0x8b, 0x38, 0x92, 0xb5, 0x2d, 0xa2, 0x47, 0x2c, 0x9c, 0x46, 0x22, 0x31, 0x0c,
	0xca, 0x82, 0xca, 0xca, 0x16, 0xa9, 0x88, 0x33, 0x87, 0x23, 0x37, 0x5d, 0xc7, 0x29, 0xdd, 0x57,
	0x63, 0xd0, 0xf8, 0x43, 0x46, 0xeb, 0x5a, 0x89, 0xf1, 0x97, 0x60, 0xe4, 0x34, 0x28, 0xea, 0x53,
	0x5b, 0xa4, 0x66, 0x42, 0x2f, 0x78, 0xc0, 0xcb, 0xa2, 0xab, 0xf6, 0x50, 0x5f, 0x25, 0x35, 0x73,
	0x7e, 0x03, 0xe3, 0x8e, 0x86, 0x9c, 0xe5, 0xf8, 0x6b, 0x30, 0x57, 0x34, 0xe0, 0x65, 0x2e, 0x02,
	0xd5, 0x7e, 0x63, 0xd4, 0xb0, 0x10, 0xd9, 0x4b, 0xb2, 0x9e, 0x95, 0x79, 0xb8, 0xef, 0xa9, 0x66,
	0xce, 0x8f, 0xd0, 0xf2, 0xe3, 0x0d, 0x9d, 0xf3, 0x60, 0x93, 0x61, 0x0b, 0xd4, 0x82, 0x86, 0xb2,
	0x1f, 0x95, 0x08, 0x28, 0x5a, 0x2c, 0x85, 0xd4, 0x90, 0x92, 0xc4, 0xce, 0xf7, 0xa0, 0x4e, 0x28,
	0x13, 0xe6, 0x84, 0xa5, 0xd2, 0x8c, 0x88, 0x80, 0x52, 0x09, 0xb8, 0xf4, 0x0a, 0x25, 0xe0, 0xce,
	0x3f, 0xa0, 0x5f, 0xc5, 0x34, 0x89, 0x44, 0x4e, 0x1a, 0x6c, 0x9e, 0x47, 0x15, 0x18, 0xdb, 0xf5,
	0xf8, 0xc2, 0x7f, 0x7c, 0x0e, 0x43, 0xe9, 0xf4, 0x1f, 0x32, 0x5a, 0x5f, 0xc5, 0x29, 0xe8, 0xf7,
	0x41, 0x52, 0x52, 0x39, 0x71, 0x67, 0xa4, 0x3d, 0xbe, 0xf9, 0x06, 0x91, 0x4a, 0xc2, 0xdf, 0x82,
	0xc1, 0x32, 0x2e, 0x96, 0xa3, 0xc9, 0xea, 0x4e, 0x55, 0xed, 0x49, 0x8d, 0xd4, 0xdf, 0x9c, 0xf7,
	0x08, 0x8c, 0x4b, 0x16, 0x8e, 0x37, 0x11, 0xfe, 0xea, 0xe0, 0xae, 0x8f, 0xcf, 0xcd, 0xa1, 0x97,
	0x1d, 0x9c, 0xf4, 0x69, 0x8d, 0x8d, 0xc3, 0x35, 0x1e, 0x3c, 0x81, 0xea, 0xd2, 0xf7, 0x14, 0x7f,
	0x07, 0x27, 0x59, 0x99, 0x24, 0xac, 0xe4, 0x8b, 0xbd, 0x43, 0xf4, 0xd1, 0x24, 0xc7, 0xb5, 0x7c,
	0x57, 0x1b, 0x31, 0x68, 0x45, 0xc2, 0x78, 0x57, 0xef, 0xa1, 0xfe, 0x11, 0x91, 0xf8, 0x60, 0x15,
	0x86, 0x7c, 0x70, 0x35, 0xc3, 0x36, 0x18, 0x2b, 0x31, 0x44, 0xd1, 0x35, 0x7b, 0x6a, 0xbf, 0x7d,
	0x6e, 0x54, 0x33, 0x91, 0x5a, 0xc5, 0x03, 0xf8, 0x2c, 0xa7, 0x3c, 0x7f, 0x58, 0xb0, 0x74, 0x11,
	0xb2, 0x74, 0x95, 0xc4, 0x21, 0xef, 0x36, 0x7b, 0xa8, 0xaf, 0x93, 0x13, 0xf9, 0xc1, 0x4b, 0xc7,
	0xb5, 0x3c, 0x18, 0x81, 0x51, 0x4d, 0x88, 0x9b, 0xa0, 0x5d, 0x7b, 0xde, 0x8d, 0xa5, 0x60, 0x00,
	0x63, 0x4c, 0xdc, 0x0b, 0xdf, 0xb5, 0x10, 0x6e, 0x81, 0xfe, 0x87, 0x4b, 0x26, 0xae, 0xd5, 0xc0,
	0x6d, 0x30, 0x89, 0x7b, 0x33, 0xbb, 0x18, 0xbb, 0x96, 0x2a, 0x3c, 0x97, 0xee, 0xcc, 0xf5, 0x5d,
	0x4b, 0x1b, 0x84, 0xd0, 0x7a, 0x5e, 0x89, 0x8c, 0xb9, 0x9d, 0xcd, 0xaa, 0x98, 0xb9, 0x4f, 0xa6,
	0xd7, 0x13, 0x0b, 0x61, 0x13, 0xd4, 0xe9, 0xb5, 0x6f, 0x35, 0x44, 0xde, 0xd5, 0xcc, 0xbb, 0xf0,
	0x2d, 0x55, 0x38, 0x47, 0x9e, 0x37, 0xb3, 0x34, 0xdc, 0x81, 0xe6, 0xc4, 0xf5, 0x6e, 0x3c, 0x61,
	0xd1, 0x85, 0x7e, 0x29, 0x0e, 0x37, 0x44, 0xc2, 0x9d, 0x3b, 0xf6, 0x3d, 0x62, 0x99, 0x03, 0x07,
	0xda, 0x07, 0x9b, 0x93, 0xc7, 0x94, 0x49, 0x62, 0x29, 0x22, 0x71, 0x9a, 0x46, 0xf4, 0x6f, 0x0b,
	0x8d, 0x7e, 0x79, 0xdc, 0xda, 0xca, 0xeb, 0xad, 0xad, 0x3c, 0x6d, 0x6d, 0xe5, 0xdd, 0xd6, 0x56,
	0x3e, 0x6c, 0x6d, 0xf4, 0xef, 0xce, 0x46, 0xff, 0xef, 0x6c, 0xf4, 0x62, 0x67, 0x2b, 0x2f, 0x77,
	0xb6, 0xf2, 0xb8, 0xb3, 0xd1, 0xab, 0x9d, 0x8d, 0x9e, 0x76, 0x36, 0xfa, 0xef, 0xad, 0xad, 0xfc,
	0x8e, 0xfe, 0xd4, 0xb2, 0x22, 0x5b, 0x2e, 0x0d, 0xf9, 0xd3, 0xff, 0xf4, 0x31, 0x00, 0x00, 0xff,
	0xff, 0xa2, 0xf4, 0xae, 0xe5, 0x30, 0x04, 0x00, 0x00,
}

func (this *UpdateSpace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateSpace)
	if !ok {
		that2, ok := that.(UpdateSpace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Space, that1.Space) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Failure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Failure)
	if !ok {
		that2, ok := that.(Failure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DocId != that1.DocId {
		return false
	}
	if this.Cause != that1.Cause {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *EngineFailure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EngineFailure)
	if !ok {
		that2, ok := that.(EngineFailure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Vector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vector)
	if !ok {
		that2, ok := that.(Vector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Feature) != len(that1.Feature) {
		return false
	}
	for i := range this.Feature {
		if this.Feature[i] != that1.Feature[i] {
			return false
		}
	}
	if this.Source != that1.Source {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TimeStamp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TimeStamp)
	if !ok {
		that2, ok := that.(TimeStamp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sec != that1.Sec {
		return false
	}
	if this.Usec != that1.Usec {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Geo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Geo)
	if !ok {
		that2, ok := that.(Geo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Lon != that1.Lon {
		return false
	}
	if this.Lat != that1.Lat {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Field) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Field)
	if !ok {
		that2, ok := that.(Field)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if this.Option != that1.Option {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DocCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DocCmd)
	if !ok {
		that2, ok := that.(DocCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.DocId != that1.DocId {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.PulloutVersion != that1.PulloutVersion {
		return false
	}
	if this.Slot != that1.Slot {
		return false
	}
	if !bytes.Equal(this.Source, that1.Source) {
		return false
	}
	if len(this.Fields) != len(that1.Fields) {
		return false
	}
	for i := range this.Fields {
		if !this.Fields[i].Equal(that1.Fields[i]) {
			return false
		}
	}
	if this.RetryOnConflict != that1.RetryOnConflict {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (m *UpdateSpace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSpace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSpace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Space) > 0 {
		i -= len(m.Space)
		copy(dAtA[i:], m.Space)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Space)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Failure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Failure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Failure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cause) > 0 {
		i -= len(m.Cause)
		copy(dAtA[i:], m.Cause)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cause)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DocId) > 0 {
		i -= len(m.DocId)
		copy(dAtA[i:], m.DocId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DocId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EngineFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EngineFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Feature) > 0 {
		for iNdEx := len(m.Feature) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float32bits(float32(m.Feature[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
		}
		i = encodeVarintApi(dAtA, i, uint64(len(m.Feature)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimeStamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeStamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeStamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Usec != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Usec))
		i--
		dAtA[i] = 0x10
	}
	if m.Sec != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Sec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Geo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Geo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Geo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lat != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lat))))
		i--
		dAtA[i] = 0x11
	}
	if m.Lon != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lon))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Option != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Option))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DocCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RetryOnConflict != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RetryOnConflict))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x32
	}
	if m.Slot != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x28
	}
	if m.PulloutVersion {
		i--
		if m.PulloutVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DocId) > 0 {
		i -= len(m.DocId)
		copy(dAtA[i:], m.DocId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DocId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedUpdateSpace(r randyApi, easy bool) *UpdateSpace {
	this := &UpdateSpace{}
	v1 := r.Intn(100)
	this.Space = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Space[i] = byte(r.Intn(256))
	}
	this.Version = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedApi(r, 3)
	}
	return this
}

func NewPopulatedFailure(r randyApi, easy bool) *Failure {
	this := &Failure{}
	this.DocId = string(randStringApi(r))
	this.Cause = string(randStringApi(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedApi(r, 3)
	}
	return this
}

func NewPopulatedEngineFailure(r randyApi, easy bool) *EngineFailure {
	this := &EngineFailure{}
	this.Type = string(randStringApi(r))
	this.Reason = string(randStringApi(r))
	this.Status = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Status *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedApi(r, 4)
	}
	return this
}

func NewPopulatedVector(r randyApi, easy bool) *Vector {
	this := &Vector{}
	v2 := r.Intn(10)
	this.Feature = make([]float32, v2)
	for i := 0; i < v2; i++ {
		this.Feature[i] = float32(r.Float32())
		if r.Intn(2) == 0 {
			this.Feature[i] *= -1
		}
	}
	this.Source = string(randStringApi(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedApi(r, 3)
	}
	return this
}

func NewPopulatedTimeStamp(r randyApi, easy bool) *TimeStamp {
	this := &TimeStamp{}
	this.Sec = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Sec *= -1
	}
	this.Usec = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Usec *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedApi(r, 3)
	}
	return this
}

func NewPopulatedGeo(r randyApi, easy bool) *Geo {
	this := &Geo{}
	this.Lon = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Lon *= -1
	}
	this.Lat = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Lat *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedApi(r, 3)
	}
	return this
}

func NewPopulatedField(r randyApi, easy bool) *Field {
	this := &Field{}
	this.Name = string(randStringApi(r))
	this.Type = FieldType([]int32{0, 1, 2, 3, 4, 5, 6, 7}[r.Intn(8)])
	v3 := r.Intn(100)
	this.Value = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Value[i] = byte(r.Intn(256))
	}
	this.Option = FieldOption([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedApi(r, 5)
	}
	return this
}

func NewPopulatedDocCmd(r randyApi, easy bool) *DocCmd {
	this := &DocCmd{}
	this.Type = OpType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.DocId = string(randStringApi(r))
	this.Version = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Version *= -1
	}
	this.PulloutVersion = bool(bool(r.Intn(2) == 0))
	this.Slot = uint32(r.Uint32())
	v4 := r.Intn(100)
	this.Source = make([]byte, v4)
	for i := 0; i < v4; i++ {
		this.Source[i] = byte(r.Intn(256))
	}
	if r.Intn(5) != 0 {
		v5 := r.Intn(5)
		this.Fields = make([]*Field, v5)
		for i := 0; i < v5; i++ {
			this.Fields[i] = NewPopulatedField(r, easy)
		}
	}
	this.RetryOnConflict = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RetryOnConflict *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedApi(r, 9)
	}
	return this
}

type randyApi interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneApi(r randyApi) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringApi(r randyApi) string {
	v6 := r.Intn(100)
	tmps := make([]rune, v6)
	for i := 0; i < v6; i++ {
		tmps[i] = randUTF8RuneApi(r)
	}
	return string(tmps)
}
func randUnrecognizedApi(r randyApi, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldApi(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldApi(dAtA []byte, r randyApi, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateApi(dAtA, uint64(key))
		v7 := r.Int63()
		if r.Intn(2) == 0 {
			v7 *= -1
		}
		dAtA = encodeVarintPopulateApi(dAtA, uint64(v7))
	case 1:
		dAtA = encodeVarintPopulateApi(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateApi(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateApi(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateApi(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateApi(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *UpdateSpace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Space)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovApi(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Failure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DocId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Cause)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EngineFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Feature) > 0 {
		n += 1 + sovApi(uint64(len(m.Feature)*4)) + len(m.Feature)*4
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeStamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sec != 0 {
		n += 1 + sovApi(uint64(m.Sec))
	}
	if m.Usec != 0 {
		n += 1 + sovApi(uint64(m.Usec))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Geo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lon != 0 {
		n += 9
	}
	if m.Lat != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Option != 0 {
		n += 1 + sovApi(uint64(m.Option))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DocCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.DocId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovApi(uint64(m.Version))
	}
	if m.PulloutVersion {
		n += 2
	}
	if m.Slot != 0 {
		n += 1 + sovApi(uint64(m.Slot))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.RetryOnConflict != 0 {
		n += 1 + sovApi(uint64(m.RetryOnConflict))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UpdateSpace) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateSpace{`,
		`Space:` + fmt.Sprintf("%v", this.Space) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Failure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Failure{`,
		`DocId:` + fmt.Sprintf("%v", this.DocId) + `,`,
		`Cause:` + fmt.Sprintf("%v", this.Cause) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EngineFailure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EngineFailure{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Vector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Vector{`,
		`Feature:` + fmt.Sprintf("%v", this.Feature) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimeStamp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimeStamp{`,
		`Sec:` + fmt.Sprintf("%v", this.Sec) + `,`,
		`Usec:` + fmt.Sprintf("%v", this.Usec) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Geo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Geo{`,
		`Lon:` + fmt.Sprintf("%v", this.Lon) + `,`,
		`Lat:` + fmt.Sprintf("%v", this.Lat) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Field) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Field{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Option:` + fmt.Sprintf("%v", this.Option) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DocCmd) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFields := "[]*Field{"
	for _, f := range this.Fields {
		repeatedStringForFields += strings.Replace(f.String(), "Field", "Field", 1) + ","
	}
	repeatedStringForFields += "}"
	s := strings.Join([]string{`&DocCmd{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`DocId:` + fmt.Sprintf("%v", this.DocId) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`PulloutVersion:` + fmt.Sprintf("%v", this.PulloutVersion) + `,`,
		`Slot:` + fmt.Sprintf("%v", this.Slot) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`Fields:` + repeatedStringForFields + `,`,
		`RetryOnConflict:` + fmt.Sprintf("%v", this.RetryOnConflict) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UpdateSpace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSpace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSpace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Space = append(m.Space[:0], dAtA[iNdEx:postIndex]...)
			if m.Space == nil {
				m.Space = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Failure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Feature = append(m.Feature, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Feature) == 0 {
					m.Feature = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Feature = append(m.Feature, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeStamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeStamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeStamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sec", wireType)
			}
			m.Sec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usec", wireType)
			}
			m.Usec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Geo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Geo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Geo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lon = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lat = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FieldType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= FieldOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= OpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PulloutVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PulloutVersion = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = append(m.Source[:0], dAtA[iNdEx:postIndex]...)
			if m.Source == nil {
				m.Source = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOnConflict", wireType)
			}
			m.RetryOnConflict = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryOnConflict |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
